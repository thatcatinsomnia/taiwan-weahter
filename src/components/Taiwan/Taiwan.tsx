/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 ./public/tw3d.glb -o ./src/components/Taiwan/text.tsx -t
*/
import type { ThreeEvent } from '@react-three/fiber';
import type { Dispatch, SetStateAction } from 'react';
import { useState, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import * as THREE from 'three';
import {
  useSpring,
  useSprings,
  animated,
  SpringRef,
  config,
  easings
} from '@react-spring/three';
import { genRandomNumber } from '../../libs/helper';
import Cloud from '../Cloud';
import Raindrop from '../Raindrop';
import Sun from '../Sun';
import useCameraControls from '../../hooks/useCameraControls';
import useTaiwanControls from '../../hooks/useTaiwanControls';
import useCloudControls from '../../hooks/useCloudControls';
import defaultPositions from '../../constants/defaultPositions';
import locations from '../../constants/locations';

type GLTFResult = GLTF & {
  nodes: {
    Scene: THREE.Group;
    KaohsiungCity: THREE.Mesh;
    PingtungCountry: THREE.Mesh;
    TainanCity: THREE.Mesh;
    HsinchuCity: THREE.Mesh;
    HsinchuCountry: THREE.Mesh;
    YilanCountry: THREE.Mesh;
    KeelungCity: THREE.Mesh;
    MiaoliCountry: THREE.Mesh;
    TaipeiCity: THREE.Mesh;
    NewTaipeiCity: THREE.Mesh;
    TaoyuanCountry: THREE.Mesh;
    ChanghuaCountry: THREE.Mesh;
    ChiayiCountry: THREE.Mesh;
    ChiayiCity: THREE.Mesh;
    HualienCountry: THREE.Mesh;
    NantouCountry: THREE.Mesh;
    TaichungCity: THREE.Mesh;
    YunlinCountry: THREE.Mesh;
    TaitungCountry: THREE.Mesh;
    PenghuCountry: THREE.Mesh;
    KinmenCountry: THREE.Mesh;
    LienchiangCountry: THREE.Mesh;
  };
  materials: {
    black: THREE.MeshStandardMaterial;
  };
};

type TMesh = THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;

type Props = JSX.IntrinsicElements['group'] & {
  wxCode?: string;
  cameraApi: SpringRef<{
    position: [x: number, y: number, z: number];
    rotationX: number;
  }>;
  setLocation: Dispatch<SetStateAction<string>>;
};

const AnimatedCloud = animated(Cloud);
const AnimatedRaindrop = animated(Raindrop);
const AnimatedSun = animated(Sun);

const RAINDROP_SIZE = 0.1;
const NUM_OF_RAINDROP = 60;
const CLOUD_SIZE = 0.06;
const SUN_SIZE = 0.026;
const SUN_INTENSITY = 0.8;
// const CAMERA_DEFAULT_POSITION: [number, number, number] = [0, 0, 5];

// check https://opendata.cwb.gov.tw/opendatadoc/MFC/ForecastElement.pdf for the code that should rain
const CODE_NOT_RAIN = ['1', '2', '3', '4', '5', '6', '7', '24', '25', '26', '27', '28', '42'];

export default function Taiwan({ cameraApi, setLocation, wxCode, ...delegated }: Props) {
  const { nodes, materials } = useGLTF('/tw3d.glb') as unknown as GLTFResult;

  const defaultMaterial = materials.black;
  const activeMaterial = new THREE.MeshStandardMaterial({ color: '#14a461' });
  const hoveredMaterial = new THREE.MeshStandardMaterial({ color: '#0a5230' });

  const {
    x: offsetX,
    y: offsetY,
    z: offsetZ,
    rotationX
  } = useCameraControls();
  const { x: taiwanX, y: taiwanY, z: taiwanZ } = useTaiwanControls();
  const { z: cloudZ } = useCloudControls();

  const taiwanPosition = new THREE.Vector3(taiwanX, taiwanY, taiwanZ);

  const [activeCity, setActiveCity] = useState<TMesh>();
  const cameraOffsetVec = new THREE.Vector3(offsetX, offsetY, offsetZ);
  
  const shouldRain = wxCode ? !CODE_NOT_RAIN.includes(wxCode) : false;

  const [cloudSprings, cloudApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9
  }));

  const [darkCloudSprings, darkCloudApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9
  }));

  const [sunSprings, sunApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9,
    rz: 0,
    intensity: 0
  }));

  const [raindropGroupSprings, raindropGroupApi] = useSprings(
    NUM_OF_RAINDROP,
    () => ({
      scale: 0,
      x: -9,
      y: -9,
      z: -9
    })
  );

  useEffect(() => {
    hideWeatherIcon();

    if (!wxCode || !activeCity) {
      return;
    }

    const newCameraPosition = activeCity.position.clone().add(cameraOffsetVec);
    startCameraAnimation(newCameraPosition);

    // we need to add taiwan position to align the camera,
    // because taiwan position is not at origin, but camera x and y is at origin
    const iconPosition = activeCity.position.clone().add(taiwanPosition);
    iconPosition.z = 0.5;
    
    startCloudAnimation(iconPosition);
    startSunAnimation(iconPosition);
    console.log(wxCode);
  }, [wxCode, activeCity]);
  
  const changeActiveCityAndUpdateStyle = (newActiveCity: TMesh) => {
    // before set the clicked mesh to the active one,
    // we need to clear the style for the current one store in state
    if (activeCity) {
      clearActiveCityAndRemoveStyle();
    }
    newActiveCity.material = activeMaterial;
    newActiveCity.position.z = 0.05;
    setActiveCity(newActiveCity);
  };

  const clearActiveCityAndRemoveStyle = () => {
    if (!activeCity) {
      return;
    }

    activeCity.material = defaultMaterial;
    activeCity.position.z = 0;
    setActiveCity(undefined);
    // activeCity.current.position.z = 0;
  };

  // const extractWeatherInfo = (location: (typeof records)[0]) => {
  //   // console.log(location.weatherElement);
  // };

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredCity = e.object as TMesh;

    if (hoveredCity.id === activeCity?.id) {
      return;
    }

    hoveredCity.material = hoveredMaterial;
  };

  const handlePointerOut = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredOutCity = e.object as TMesh;

    if (hoveredOutCity.id !== activeCity?.id) {
      hoveredOutCity.material = defaultMaterial;
    }
  };

  const hideWeatherIcon = () => {
    // stop animation first, otherwise the raindrop animation will be strange when click between city
    // commment it to see the difference
    cloudApi.stop(true);
    darkCloudApi.stop(true);
    sunApi.stop(true);
    raindropGroupApi.stop(true);

    cloudApi.set({ scale: 0 });
    darkCloudApi.set({ scale: 0 });
    sunApi.set({ scale: 0, intensity: 0 });
    raindropGroupApi.set({ scale: 0 });
  };

  const startCameraAnimation = (position: THREE.Vector3) => {
    const newPosition = position.toArray();

    cameraApi.start({
      to: {
        position: newPosition,
        rotationX: rotationX
      }
    });
  };

  const startCloudAnimation = (position: THREE.Vector3) => {
    if (wxCode === '1') {
      return;
    }

    cloudApi.set({
      scale: 0,
      x: position.x,
      y: position.y,
      z: position.z
    });

    darkCloudApi.set({
      scale: 0,
      x: position.x,
      y: position.y,
      z: position.z
    });

    cloudApi.start({
      from: {
        scale: 0
      },
      to: {
        scale: CLOUD_SIZE
      },
      delay: 360,
      config: config.wobbly,
      onRest: (result) => {
        if (result.cancelled) {
          return;
        }

        startRainAnimation(position);
      }
    });

    if (wxCode === '5') {
      // 多雲
      darkCloudApi.start({
        from: {
          x: position.x,
          y: position.y,
          z: position.z,
          scale: 0
        },
        to: {
          x: position.x + 0.12,
          y: position.y + 0.05,
          z: position.z + 0.1,
          scale: 0.044
        },
        delay: 360,
        config: config.wobbly
      });
    } else if (wxCode === '6') {

    }
  };
  
  const startRainAnimation = (position: THREE.Vector3) => {
    // make raindrop position random
    // the value below is find by using leva to manually find the acceptable value
    // rangeX: [-0.1, 0.13]
    // raingeY: [-0.05, 0.05]
    raindropGroupSprings.map((springs, i) => {
      const basePosition = position.clone();
      const randomX = genRandomNumber(-0.1, 0.13);
      const randomY = genRandomNumber(-0.05, 0.05);

      const newPosition = basePosition.add(
        new THREE.Vector3(randomX, randomY, 0)
      );

      springs.x.set(newPosition.x);
      springs.y.set(newPosition.y);
      springs.z.set(cloudZ);
    });

    if (shouldRain) {
      raindropGroupApi.start(i => ({
        from: {
          z: cloudZ,
          scale: RAINDROP_SIZE
        },
        to: async (next, cancel) => {
          await next({ z: 0 });
          await next({ scale: 0 });
        },
        delay: Math.random() * i * 200,
        loop: true,
        config: {
          duration: 800,
          easing: easings.linear
        }
      }));
    }
  };

  const startSunAnimation = (position: THREE.Vector3) => {
    sunApi.set({
      scale: 0,
      intensity: 0.5,
      x: position.x,
      y: position.y,
      z: position.z
    });

    if (wxCode === '1') {
      // 1 晴天
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          z: position.z - 0.1,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x,
          z: position.z,
          rz: -Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 300
      });
    } else if (wxCode === '2') {
      // 2 晴時多雲
      sunApi.start({
        from: {
          scale: 0,
          x: position.x + 0.08,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          // x: position.x - 0.1,
          // y: position.y - 0.1,
          x: position.x - 0.1,
          y: position.y - 0.07,
          z: position.z + 0.14,
          rz: Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 360
      });
    } else if (wxCode === '3') {
      // 3 多雲時晴
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x + 0.1,
          y: position.y + 0.08,
          z: position.z + 0.1,
          rz: -Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 360
      });
    } else if (wxCode === '4') {
      // 4 多雲
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x + 0.1,
          y: position.y + 0.1,
          z: position.z + 0.05,
          rz: -Math.PI,
          intensity: 0.05 
        },
        config: config.wobbly,
        delay: 360
      });
    }

  }

  const handleClick = (e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation();
    const clickedCity = e.object as TMesh;

    if (clickedCity.id === activeCity?.id) {
      return;
    }

    // hideWeatherIcon();

    const newCameraPosition = clickedCity.position.clone();
    newCameraPosition.add(cameraOffsetVec);

    const cloudDelayTime = 360;
    
    setLocation(locations[clickedCity.name as keyof typeof locations]);

    changeActiveCityAndUpdateStyle(clickedCity);
  };

  const handlePointerMissed = (e: MouseEvent) => {
    if (activeCity) {
      hideWeatherIcon();

      cameraApi.start({
        to: {
          position: defaultPositions.camera,
          rotationX: 0
        },
        config: {
          easing: easings.easeOutQuad,
          duration: 500
        }
      });

      clearActiveCityAndRemoveStyle();
    }

    setLocation('');
  };

  return (
    <>
      <AnimatedCloud
        x={cloudSprings.x}
        y={cloudSprings.y}
        z={cloudSprings.z}
        scale={cloudSprings.scale}
      />

      <AnimatedCloud
        x={darkCloudSprings.x}
        y={darkCloudSprings.y}
        z={darkCloudSprings.z}
        scale={darkCloudSprings.scale}
        dark
      />

      {raindropGroupSprings.map(({ x, y, z, scale }, i) => (
        <AnimatedRaindrop key={i} x={x} y={y} z={z} scale={scale} />
      ))}

      <AnimatedSun
        x={sunSprings.x}
        y={sunSprings.y}
        z={sunSprings.z}
        scale={sunSprings.scale}
        rz={sunSprings.rz}
        intensity={sunSprings.intensity}
      />

      <group
        {...delegated}
        dispose={null}
        position={taiwanPosition}
        onClick={handleClick}
        onPointerMissed={handlePointerMissed}
        onPointerOver={handlePointerOver}
        onPointerOut={handlePointerOut}
      >
        <mesh
          name="KaohsiungCity"
          geometry={nodes.KaohsiungCity.geometry}
          material={materials.black}
          position={[-0.033462, -0.666731, 0]}
        />
        <mesh
          name="PingtungCountry"
          geometry={nodes.PingtungCountry.geometry}
          material={materials.black}
          position={[0.003678, -1.036683, 0]}
        />
        <mesh
          name="TainanCity"
          geometry={nodes.TainanCity.geometry}
          material={materials.black}
          position={[-0.223662, -0.554262, 0]}
        />
        <mesh
          name="HsinchuCity"
          geometry={nodes.HsinchuCity.geometry}
          material={materials.black}
          position={[0.190276, 0.636097, 0]}
        />
        <mesh
          name="HsinchuCountry"
          geometry={nodes.HsinchuCountry.geometry}
          material={materials.black}
          position={[0.32923, 0.566177, 0]}
        />
        <mesh
          name="YilanCountry"
          geometry={nodes.YilanCountry.geometry}
          material={materials.black}
          position={[0.646409, 0.485567, 0]}
        />
        <mesh
          name="KeelungCity"
          geometry={nodes.KeelungCity.geometry}
          material={materials.black}
          position={[0.694483, 0.879278, 0]}
        />
        <mesh
          name="MiaoliCountry"
          geometry={nodes.MiaoliCountry.geometry}
          material={materials.black}
          position={[0.166294, 0.420212, 0]}
        />
        <mesh
          name="TaipeiCity"
          geometry={nodes.TaipeiCity.geometry}
          material={materials.black}
          position={[0.595474, 0.856797, 0]}
        />
        <mesh
          name="NewTaipeiCity"
          geometry={nodes.NewTaipeiCity.geometry}
          material={materials.black}
          position={[0.615812, 0.786084, 0]}
        />
        <mesh
          name="TaoyuanCountry"
          geometry={nodes.TaoyuanCountry.geometry}
          material={materials.black}
          position={[0.397512, 0.721097, 0]}
        />
        <mesh
          name="ChanghuaCountry"
          geometry={nodes.ChanghuaCountry.geometry}
          material={materials.black}
          position={[-0.12405, 0.03245, 0]}
        />
        <mesh
          name="ChiayiCountry"
          geometry={nodes.ChiayiCountry.geometry}
          material={materials.black}
          position={[-0.099615, -0.336385, 0]}
        />
        <mesh
          name="ChiayiCity"
          geometry={nodes.ChiayiCity.geometry}
          material={materials.black}
          position={[-0.15079, -0.315262, 0]}
        />
        <mesh
          name="HualienCountry"
          geometry={nodes.HualienCountry.geometry}
          material={materials.black}
          position={[0.473711, -0.116171, 0]}
        />
        <mesh
          name="NantouCountry"
          geometry={nodes.NantouCountry.geometry}
          material={materials.black}
          position={[0.212877, -0.048316, 0]}
        />
        <mesh
          name="TaichungCity"
          geometry={nodes.TaichungCity.geometry}
          material={materials.black}
          position={[0.150413, 0.241351, 0]}
        />
        <mesh
          name="YunlinCountry"
          geometry={nodes.YunlinCountry.geometry}
          material={materials.black}
          position={[-0.186642, -0.165699, 0]}
        />
        <mesh
          name="TaitungCountry"
          geometry={nodes.TaitungCountry.geometry}
          material={materials.black}
          position={[0.248513, -0.762825, 0]}
        />
        <mesh
          name="PenghuCountry"
          geometry={nodes.PenghuCountry.geometry}
          material={materials.black}
          position={[-0.764586, -0.519908, 0]}
        />
        <mesh
          name="KinmenCountry"
          geometry={nodes.KinmenCountry.geometry}
          material={materials.black}
          position={[-0.68671, 0.190579, 0]}
        />
        <mesh
          name="LienchiangCountry"
          geometry={nodes.LienchiangCountry.geometry}
          material={materials.black}
          position={[-0.428144, 0.965172, 0]}
        />
      </group>
    </>
  );
}

useGLTF.preload('/tw3d.glb');
