/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 ./public/tw3d.glb -o ./src/components/Taiwan/text.tsx -t
*/
import type { ThreeEvent } from '@react-three/fiber';
import { useEffect, useRef, forwardRef, ForwardedRef  } from 'react';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import * as THREE from 'three';
import {
  useSpring,
  useSprings,
  animated,
  SpringRef,
  config,
  easings
} from '@react-spring/three';
import { genRandomNumber } from '../../libs/helper';
import Cloud from '../Cloud';
import Raindrop from '../Raindrop';
import Sun from '../Sun';
import useDefaultPositions from '../../hooks/useDefaultPositions';
import { useSelectedCity } from '../../hooks/useSelectedCity';

type GLTFResult = GLTF & {
  nodes: {
    Scene: THREE.Group;
    KaohsiungCity: THREE.Mesh;
    PingtungCountry: THREE.Mesh;
    TainanCity: THREE.Mesh;
    HsinchuCity: THREE.Mesh;
    HsinchuCountry: THREE.Mesh;
    YilanCountry: THREE.Mesh;
    KeelungCity: THREE.Mesh;
    MiaoliCountry: THREE.Mesh;
    TaipeiCity: THREE.Mesh;
    NewTaipeiCity: THREE.Mesh;
    TaoyuanCountry: THREE.Mesh;
    ChanghuaCountry: THREE.Mesh;
    ChiayiCountry: THREE.Mesh;
    ChiayiCity: THREE.Mesh;
    HualienCountry: THREE.Mesh;
    NantouCountry: THREE.Mesh;
    TaichungCity: THREE.Mesh;
    YunlinCountry: THREE.Mesh;
    TaitungCountry: THREE.Mesh;
    PenghuCountry: THREE.Mesh;
    KinmenCountry: THREE.Mesh;
    LienchiangCountry: THREE.Mesh;
  };
  materials: {
    black: THREE.MeshStandardMaterial;
  };
};

export type TMesh = THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;

type Props = JSX.IntrinsicElements['group'] & {
  cameraApi: SpringRef<{
    position: [x: number, y: number, z: number];
    rotationX: number;
  }>;
};

const AnimatedCloud = animated(Cloud);
const AnimatedRaindrop = animated(Raindrop);
const AnimatedSun = animated(Sun);

const RAINDROP_SIZE = 0.1;
const NUM_OF_RAINDROP = 60;
const CLOUD_SIZE = 0.06;
const SUN_SIZE = 0.026;
const SUN_INTENSITY = 0.8;

// check https://opendata.cwb.gov.tw/opendatadoc/MFC/ForecastElement.pdf for the code that should rain
const CODE_NOT_RAIN = ['1', '2', '3', '4', '5', '6', '7', '24', '25', '26', '27', '28', '42'];

// use custom forwardRef to check if ref is function or not, then replace it with the "inner" ref
// check issue for more information: https://github.com/facebook/react/issues/24722
const useForwardRef = <T,>(
  ref: ForwardedRef<T>,
  initialValue: any = null
) => {
  const targetRef = useRef<T>(initialValue);

  useEffect(() => {
    if (!ref) return;

    if (typeof ref === 'function') {
      ref(targetRef.current);
    } else {
      ref.current = targetRef.current;
    }
  }, [ref]);

  return targetRef;
};

const Taiwan = forwardRef<THREE.Group, Props>((props, ref) => {
  const taiwanRef = useForwardRef(ref);
  const { cameraApi, ...delegated } = props;
  const { weather, setWeather, selectedCity, setSelectedCity } = useSelectedCity();
  
  const { nodes, materials } = useGLTF('/tw3d.glb') as unknown as GLTFResult;
  const defaultMaterial = materials.black;
  const activeMaterial = new THREE.MeshStandardMaterial({ color: '#14a461' });
  const hoveredMaterial = new THREE.MeshStandardMaterial({ color: '#0a5230' });

  const { camera, taiwan } = useDefaultPositions();

  const cameraOffsetVec = new THREE.Vector3(camera.offset.x, camera.offset.y, camera.offset.z);

  const wxCode = weather?.wx?.code;
  const shouldRain = wxCode ? !CODE_NOT_RAIN.includes(wxCode) : false;
  const [cloudSprings, cloudApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9
  }));

  const [darkCloudSprings, darkCloudApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9
  }));

  const [sunSprings, sunApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9,
    rz: 0,
    intensity: 0
  }));

  const [raindropGroupSprings, raindropGroupApi] = useSprings(
    NUM_OF_RAINDROP,
    () => ({
      scale: 0,
      x: -9,
      y: -9,
      z: -9
    })
  );

  useEffect(() => {
    if (!selectedCity) {
      hideWeatherIcon();

      cameraApi.start({
        to: {
          position: [camera.position.x, camera.position.y, camera.position.z],
          rotationX: 0
        },
        config: {
          easing: easings.easeOutQuad,
          duration: 500
        }
      });

      clearAllCityStyle();
      
      return;
    }

    hideWeatherIcon();
    clearAllCityStyle();
    updateActiveCityStyle();

    // animate camera to selected city position in 3d world
    const newCameraPosition = selectedCity.position.clone();
    newCameraPosition.add(cameraOffsetVec);

    cameraApi.start({
      to: {
        position: newCameraPosition.toArray(),
        rotationX: camera.rx
      }
    });

    // we need to add taiwan position to align the camera,
    // because taiwan position is not at origin, but camera x and y is at origin
    const iconPosition = selectedCity.position.clone().add(new THREE.Vector3(taiwan.position.x, taiwan.position.y, taiwan.position.z));
    iconPosition.z = 0.5;
    
    startCloudAnimation(iconPosition);
    startSunAnimation(iconPosition);
  }, [selectedCity, weather]);
  
  const clearAllCityStyle = () => {
    taiwanRef?.current.children.forEach(mesh => {
      (mesh as TMesh).material = defaultMaterial;
      (mesh as TMesh).position.z = 0;
    });
  };

  const updateActiveCityStyle = () => {
    const activeMesh = taiwanRef?.current.children.find(mesh => mesh.name === selectedCity?.name) as TMesh;

    if (activeMesh) {
      activeMesh.material = activeMaterial;
      activeMesh.position.z = 0.05;
    }
  };

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredCity = e.object as TMesh;

    if (hoveredCity.id === selectedCity?.id) {
      return;
    }

    hoveredCity.material = hoveredMaterial;
  };

  const handlePointerOut = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredOutCity = e.object as TMesh;

    if (hoveredOutCity.id !== selectedCity?.id) {
      hoveredOutCity.material = defaultMaterial;
    }
  };

  const hideWeatherIcon = () => {
    // stop animation first, otherwise the raindrop animation will be strange when click between city
    // commment it to see the difference
    cloudApi.stop(true);
    darkCloudApi.stop(true);
    sunApi.stop(true);
    raindropGroupApi.stop(true);

    cloudApi.set({ scale: 0 });
    darkCloudApi.set({ scale: 0 });
    sunApi.set({ scale: 0, intensity: 0 });
    raindropGroupApi.set({ scale: 0 });
  };
  
  const startCloudAnimation = (position: THREE.Vector3) => {
    if (wxCode === '1') {
      return;
    }

    cloudApi.set({
      scale: 0,
      x: position.x,
      y: position.y,
      z: position.z
    });

    darkCloudApi.set({
      scale: 0,
      x: position.x,
      y: position.y,
      z: position.z
    });

    cloudApi.start({
      from: {
        scale: 0
      },
      to: {
        scale: CLOUD_SIZE
      },
      delay: 360,
      config: config.wobbly,
      onRest: (result) => {
        if (result.cancelled) {
          return;
        }
        
        if (shouldRain) {
          startRainAnimation(position);
        }
      }
    });

    if (wxCode === '5') {
      // 多雲
      darkCloudApi.start({
        from: {
          x: position.x,
          y: position.y,
          z: position.z,
          scale: 0
        },
        to: {
          x: position.x + 0.12,
          y: position.y + 0.05,
          z: position.z + 0.1,
          scale: 0.044
        },
        delay: 360,
        config: config.wobbly
      });
    }
  };
  
  const startRainAnimation = (position: THREE.Vector3) => {
    // make raindrop position random
    // the value below is find by using leva to manually find the acceptable value
    // rangeX: [-0.1, 0.13]
    // raingeY: [-0.05, 0.05]
    raindropGroupSprings.map((springs, i) => {
      const basePosition = position.clone();
      const randomX = genRandomNumber(-0.1, 0.13);
      const randomY = genRandomNumber(-0.05, 0.05);

      // do not add z axis, make it equal to cloud z position
      const newPosition = basePosition.add(
        new THREE.Vector3(randomX, randomY, 0)
      );

      springs.x.set(newPosition.x);
      springs.y.set(newPosition.y);
      springs.z.set(newPosition.z);
    });

    raindropGroupApi.start(i => ({
      from: {
        scale: RAINDROP_SIZE,
        z: position.z
      },
      to: async (next, cancel) => {
        await next({ z: 0 });
        await next({ scale: 0 });
      },
      delay: Math.random() * i * 200,
      loop: true,
      config: {
        duration: 800,
        easing: easings.linear
      }
    }));
  };

  const startSunAnimation = (position: THREE.Vector3) => {
    sunApi.set({
      scale: 0,
      intensity: 0.5,
      x: position.x,
      y: position.y,
      z: position.z
    });
    
    
    if (wxCode === '1') {
      // 1 晴天
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          z: position.z - 0.1,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x,
          z: position.z,
          rz: -Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 300
      });
    } else if (wxCode === '2') {
      // 2 晴時多雲
      sunApi.start({
        from: {
          scale: 0,
          x: position.x + 0.08,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x - 0.1,
          y: position.y - 0.07,
          z: position.z + 0.14,
          rz: Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 360
      });
    } else if (wxCode === '3') {
      // 3 多雲時晴
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x + 0.1,
          y: position.y + 0.08,
          z: position.z + 0.1,
          rz: -Math.PI,
          intensity: SUN_INTENSITY 
        },
        config: config.wobbly,
        delay: 360
      });
    } else if (wxCode === '4') {
      // 4 多雲
      sunApi.start({
        from: {
          scale: 0,
          x: position.x,
          y: position.y,
          z: position.z,
          rz: 0,
          intensity: 0
        },
        to: {
          scale: SUN_SIZE,
          x: position.x + 0.1,
          y: position.y + 0.1,
          z: position.z + 0.05,
          rz: -Math.PI,
          intensity: 0.05 
        },
        config: config.wobbly,
        delay: 360
      });
    }
  }

  const handleClick = (e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation();
    
    const clickedCity = e.object as TMesh;

    if (!clickedCity) {
      return;
    }

    if (clickedCity.id === selectedCity?.id) {
      return;
    }

    setSelectedCity(clickedCity);
  };

  const handlePointerMissed = (e: MouseEvent) => {
    if (selectedCity) {
      hideWeatherIcon();

      cameraApi.start({
        to: {
          position: [camera.position.x, camera.position.y, camera.position.z],
          rotationX: 0
        },
        config: {
          easing: easings.easeOutQuad,
          duration: 500
        }
      });

      clearAllCityStyle();
    }

    setSelectedCity(undefined);
    setWeather(undefined);
  };
  
  return (
    <>
      <AnimatedCloud
        x={cloudSprings.x}
        y={cloudSprings.y}
        z={cloudSprings.z}
        scale={cloudSprings.scale}
      />

      <AnimatedCloud
        x={darkCloudSprings.x}
        y={darkCloudSprings.y}
        z={darkCloudSprings.z}
        scale={darkCloudSprings.scale}
        dark
      />

      {raindropGroupSprings.map(({ x, y, z, scale }, i) => (
        <AnimatedRaindrop key={i} x={x} y={y} z={z} scale={scale} />
      ))}

      <AnimatedSun
        x={sunSprings.x}
        y={sunSprings.y}
        z={sunSprings.z}
        scale={sunSprings.scale}
        rz={sunSprings.rz}
        intensity={sunSprings.intensity}
      />

      <group
        {...delegated}
        dispose={null}
        ref={taiwanRef}
        position-x={taiwan.position.x}
        position-y={taiwan.position.y}
        position-z={taiwan.position.z}
        onClick={handleClick}
        onPointerMissed={handlePointerMissed}
        onPointerOver={handlePointerOver}
        onPointerOut={handlePointerOut}
      >
        <mesh
          name="KaohsiungCity"
          geometry={nodes.KaohsiungCity.geometry}
          material={materials.black}
          position={[-0.033462, -0.666731, 0]}
        />
        <mesh
          name="PingtungCountry"
          geometry={nodes.PingtungCountry.geometry}
          material={materials.black}
          position={[0.003678, -1.036683, 0]}
        />
        <mesh
          name="TainanCity"
          geometry={nodes.TainanCity.geometry}
          material={materials.black}
          position={[-0.223662, -0.554262, 0]}
        />
        <mesh
          name="HsinchuCity"
          geometry={nodes.HsinchuCity.geometry}
          material={materials.black}
          position={[0.190276, 0.636097, 0]}
        />
        <mesh
          name="HsinchuCountry"
          geometry={nodes.HsinchuCountry.geometry}
          material={materials.black}
          position={[0.32923, 0.566177, 0]}
        />
        <mesh
          name="YilanCountry"
          geometry={nodes.YilanCountry.geometry}
          material={materials.black}
          position={[0.646409, 0.485567, 0]}
        />
        <mesh
          name="KeelungCity"
          geometry={nodes.KeelungCity.geometry}
          material={materials.black}
          position={[0.694483, 0.879278, 0]}
        />
        <mesh
          name="MiaoliCountry"
          geometry={nodes.MiaoliCountry.geometry}
          material={materials.black}
          position={[0.166294, 0.420212, 0]}
        />
        <mesh
          name="TaipeiCity"
          geometry={nodes.TaipeiCity.geometry}
          material={materials.black}
          position={[0.595474, 0.856797, 0]}
        />
        <mesh
          name="NewTaipeiCity"
          geometry={nodes.NewTaipeiCity.geometry}
          material={materials.black}
          position={[0.615812, 0.786084, 0]}
        />
        <mesh
          name="TaoyuanCountry"
          geometry={nodes.TaoyuanCountry.geometry}
          material={materials.black}
          position={[0.397512, 0.721097, 0]}
        />
        <mesh
          name="ChanghuaCountry"
          geometry={nodes.ChanghuaCountry.geometry}
          material={materials.black}
          position={[-0.12405, 0.03245, 0]}
        />
        <mesh
          name="ChiayiCountry"
          geometry={nodes.ChiayiCountry.geometry}
          material={materials.black}
          position={[-0.099615, -0.336385, 0]}
        />
        <mesh
          name="ChiayiCity"
          geometry={nodes.ChiayiCity.geometry}
          material={materials.black}
          position={[-0.15079, -0.315262, 0]}
        />
        <mesh
          name="HualienCountry"
          geometry={nodes.HualienCountry.geometry}
          material={materials.black}
          position={[0.473711, -0.116171, 0]}
        />
        <mesh
          name="NantouCountry"
          geometry={nodes.NantouCountry.geometry}
          material={materials.black}
          position={[0.212877, -0.048316, 0]}
        />
        <mesh
          name="TaichungCity"
          geometry={nodes.TaichungCity.geometry}
          material={materials.black}
          position={[0.150413, 0.241351, 0]}
        />
        <mesh
          name="YunlinCountry"
          geometry={nodes.YunlinCountry.geometry}
          material={materials.black}
          position={[-0.186642, -0.165699, 0]}
        />
        <mesh
          name="TaitungCountry"
          geometry={nodes.TaitungCountry.geometry}
          material={materials.black}
          position={[0.248513, -0.762825, 0]}
        />
        <mesh
          name="PenghuCountry"
          geometry={nodes.PenghuCountry.geometry}
          material={materials.black}
          position={[-0.764586, -0.519908, 0]}
        />
        <mesh
          name="KinmenCountry"
          geometry={nodes.KinmenCountry.geometry}
          material={materials.black}
          position={[-0.68671, 0.190579, 0]}
        />
        <mesh
          name="LienchiangCountry"
          geometry={nodes.LienchiangCountry.geometry}
          material={materials.black}
          position={[-0.428144, 0.965172, 0]}
        />
      </group>
    </>
  );
});

export default Taiwan;

useGLTF.preload('/tw3d.glb');
