/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.3 ./public/tw3d.glb -o ./src/components/Taiwan/text.tsx -t
*/
import type { ThreeEvent } from '@react-three/fiber';
import type { Dispatch, SetStateAction } from 'react';
import { useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import * as THREE from 'three';
import {
  useSpring,
  useSprings,
  animated,
  SpringRef,
  config,
  easings
} from '@react-spring/three';
import { genRandomNumber } from '../../libs/helper';
import Cloud from '../Cloud';
import Raindrop from '../Raindrop';
import Sun from '../Sun';
import useCameraControls from '../../hooks/useCameraControls';
import useTaiwanControls from '../../hooks/useTaiwanControls';
import useCloudControls from '../../hooks/useCloudControls';
import locations from '../../constants/locations';

type GLTFResult = GLTF & {
  nodes: {
    Scene: THREE.Group;
    KaohsiungCity: THREE.Mesh;
    PingtungCountry: THREE.Mesh;
    TainanCity: THREE.Mesh;
    HsinchuCity: THREE.Mesh;
    HsinchuCountry: THREE.Mesh;
    YilanCountry: THREE.Mesh;
    KeelungCity: THREE.Mesh;
    MiaoliCountry: THREE.Mesh;
    TaipeiCity: THREE.Mesh;
    NewTaipeiCity: THREE.Mesh;
    TaoyuanCountry: THREE.Mesh;
    ChanghuaCountry: THREE.Mesh;
    ChiayiCountry: THREE.Mesh;
    ChiayiCity: THREE.Mesh;
    HualienCountry: THREE.Mesh;
    NantouCountry: THREE.Mesh;
    TaichungCity: THREE.Mesh;
    YunlinCountry: THREE.Mesh;
    TaitungCountry: THREE.Mesh;
    PenghuCountry: THREE.Mesh;
    KinmenCountry: THREE.Mesh;
    LienchiangCountry: THREE.Mesh;
  };
  materials: {
    black: THREE.MeshStandardMaterial;
  };
};

type TMesh = THREE.Mesh<THREE.BufferGeometry, THREE.MeshStandardMaterial>;

type Props = JSX.IntrinsicElements['group'] & {
  cameraApi: SpringRef<{
    position: [x: number, y: number, z: number];
    rotationX: number;
  }>;

  setLocation: Dispatch<SetStateAction<string>>;
};

const AnimatedCloud = animated(Cloud);
const AnimatedRaindrop = animated(Raindrop);
const AnimatedSun = animated(Sun);

const RAINDROP_SIZE = 0.1;
const NUM_OF_RAINDROP = 60;
const CLOUD_SIZE = 0.06;
const SUN_SIZE = 0.026;
const SUN_INTENSITY = 0.8;
const CAMERA_DEFAULT_POSITION: [number, number, number] = [0, 0, 5];

export default function Taiwan({ cameraApi, setLocation, ...delegated }: Props) {
  const { nodes, materials } = useGLTF('/tw3d.glb') as unknown as GLTFResult;

  const defaultMaterial = materials.black;
  const activeMaterial = new THREE.MeshStandardMaterial({ color: '#14a461' });
  const hoveredMaterial = new THREE.MeshStandardMaterial({ color: '#0a5230' });

  const {
    x: offsetX,
    y: offsetY,
    z: offsetZ,
    rotationX
  } = useCameraControls();
  const { x: taiwanX, y: taiwanY, z: taiwanZ } = useTaiwanControls();
  const { z: cloudZ, wireframe } = useCloudControls();

  const taiwanPosition = new THREE.Vector3(taiwanX, taiwanY, taiwanZ);

  const [activeCity, setActiveCity] = useState<TMesh>();
  const [weather, setWeather] = useState<'cloud' | 'rain' | 'sun'>();
  const cameraOffsetVec = new THREE.Vector3(offsetX, offsetY, offsetZ);

  const [cloudSprings, cloudApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9
  }));

  const [sunSprings, sunApi] = useSpring(() => ({
    scale: 0,
    x: -9,
    y: -9,
    z: -9,
    rz: 0,
    intensity: 0
  }));

  const [raindropGroupSprings, raindropGroupApi] = useSprings(
    NUM_OF_RAINDROP,
    () => ({
      scale: 0,
      x: -9,
      y: -9,
      z: -9
    })
  );

  const changeActiveCityAndUpdateStyle = (newActiveCity: TMesh) => {
    // before set the clicked mesh to the active one,
    // we need to clear the style for the current one store in state
    if (activeCity) {
      clearActiveCityAndRemoveStyle();
    }
    newActiveCity.material = activeMaterial;
    newActiveCity.position.z = 0.06;
    setActiveCity(newActiveCity);
  };

  const clearActiveCityAndRemoveStyle = () => {
    if (!activeCity) {
      return;
    }

    activeCity.material = defaultMaterial;
    activeCity.position.z = 0;
    setActiveCity(undefined);
    // activeCity.current.position.z = 0;
  };

  // const extractWeatherInfo = (location: (typeof records)[0]) => {
  //   // console.log(location.weatherElement);
  // };

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredCity = e.object as TMesh;

    if (hoveredCity.id === activeCity?.id) {
      return;
    }

    hoveredCity.material = hoveredMaterial;
  };

  const handlePointerOut = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();

    const hoveredOutCity = e.object as TMesh;

    if (hoveredOutCity.id !== activeCity?.id) {
      hoveredOutCity.material = defaultMaterial;
    }
  };

  const hideWeatherIcon = () => {
    // stop animation first, otherwise the raindrop animation will be strange when click between city
    // commment it to see the difference
    cloudApi.stop(true);
    sunApi.stop(true);
    raindropGroupApi.stop(true);

    cloudApi.set({ scale: 0 });
    sunApi.set({ scale: 0, intensity: 0 });
    raindropGroupApi.set({ scale: 0 });
  };

  const handleClick = (e: ThreeEvent<MouseEvent>) => {
    e.stopPropagation();
    const clickedCity = e.object as TMesh;

    if (clickedCity.id === activeCity?.id) {
      return;
    }

    hideWeatherIcon();

    const newCameraPosition = clickedCity.position.clone();
    newCameraPosition.add(cameraOffsetVec);

    const cloudDelayTime = 360;
    
    setLocation(locations[clickedCity.name as keyof typeof locations]);

    if (activeCity === undefined) {
      cameraApi.start({
        to: {
          position: newCameraPosition.toArray(),
          rotationX: rotationX
        },
        config: {
          easing: easings.easeOutQuad,
          duration: 500
        }
      });
    } else if (activeCity?.id !== clickedCity.id) {
      cameraApi.start({
        to: {
          position: newCameraPosition.toArray()
        }
      });
    }

    // we need to add taiwan position to align the camera,
    // because taiwan position is not at origin, but camera x and y is at origin
    const newCloudPosition = clickedCity.position.clone().add(taiwanPosition);
    newCloudPosition.z = cloudZ;

    cloudApi.set({
      scale: 0,
      x: newCloudPosition.x,
      y: newCloudPosition.y,
      z: newCloudPosition.z
    });

    const newSunPosition = newCloudPosition
      .clone()
      .add(new THREE.Vector3(0.16, 0, 0.12));
    sunApi.set({
      scale: 0,
      intensity: 0,
      x: newSunPosition.x,
      y: newSunPosition.y,
      z: newSunPosition.z
    });

    cloudApi.start({
      from: {
        scale: 0
      },
      to: {
        scale: CLOUD_SIZE
      },
      delay: cloudDelayTime,
      config: config.wobbly,
      onRest: (result) => {
        if (result.cancelled) {
          return;
        }

        const isRain = false;
        // make raindrop position random
        // the value below is find by using leva to manually find the acceptable value
        // rangeX: [-0.1, 0.13]
        // raingeY: [-0.05, 0.05]
          raindropGroupSprings.map((springs, i) => {
            const basePosition = newCloudPosition.clone();
            const randomX = genRandomNumber(-0.1, 0.13);
            const randomY = genRandomNumber(-0.05, 0.05);

            const newPosition = basePosition.add(
              new THREE.Vector3(randomX, randomY, 0)
            );

            springs.x.set(newPosition.x);
            springs.y.set(newPosition.y);
            springs.z.set(cloudZ);
          });

          raindropGroupApi.start(i => ({
            from: {
              z: cloudZ,
              scale: RAINDROP_SIZE
            },
            to: async (next, cancel) => {
              await next({ z: 0 });
              await next({ scale: 0 });
            },
            delay: Math.random() * i * 200,
            loop: true,
            config: {
              duration: 800,
              easing: easings.linear
            }
          }));

          sunApi.start({
            from: {
              scale: 0,
              x: newSunPosition.x - 0.3,
              z: newSunPosition.z - 0.1,
              rz: 0,
              intensity: 0
            },
            to: {
              scale: SUN_SIZE,
              x: newSunPosition.x,
              z: newSunPosition.z,
              rz: -Math.PI,
              intensity: SUN_INTENSITY 
            }
          });
        }
    });

    const weathers = ['rain', 'cloud'] as const;
    const random = Math.floor(Math.random() * weathers.length);

    setWeather(weathers[random]);
    changeActiveCityAndUpdateStyle(clickedCity);
    // const locationName = locations[clickedCity.name as keyof typeof locations];
    // const activeWeather = records.find(record => record.locationName === locationName);
    // const weatherInfo = extractWeatherInfo(activeWeather);
  };

  const handlePointerMissed = (e: MouseEvent) => {
    if (activeCity) {
      hideWeatherIcon();

      cameraApi.start({
        to: {
          position: CAMERA_DEFAULT_POSITION,
          rotationX: 0
        },
        config: {
          easing: easings.easeOutQuad,
          duration: 500
        }
      });

      clearActiveCityAndRemoveStyle();
    }

    setLocation('');
    setWeather(undefined);
  };

  return (
    <>
      <group>
        <AnimatedCloud
          x={cloudSprings.x}
          y={cloudSprings.y}
          z={cloudSprings.z}
          scale={cloudSprings.scale}
          wireframe={wireframe}
        />
      </group>

      {raindropGroupSprings.map(({ x, y, z, scale }, i) => (
        <AnimatedRaindrop key={i} x={x} y={y} z={z} scale={scale} />
      ))}

      <AnimatedSun
        x={sunSprings.x}
        y={sunSprings.y}
        z={sunSprings.z}
        scale={sunSprings.scale}
        rz={sunSprings.rz}
        intensity={sunSprings.intensity}
      />

      <group
        {...delegated}
        dispose={null}
        position={taiwanPosition}
        onClick={handleClick}
        onPointerMissed={handlePointerMissed}
        onPointerOver={handlePointerOver}
        onPointerOut={handlePointerOut}
      >
        <mesh
          name="KaohsiungCity"
          geometry={nodes.KaohsiungCity.geometry}
          material={materials.black}
          position={[-0.033462, -0.666731, 0]}
        />
        <mesh
          name="PingtungCountry"
          geometry={nodes.PingtungCountry.geometry}
          material={materials.black}
          position={[0.003678, -1.036683, 0]}
        />
        <mesh
          name="TainanCity"
          geometry={nodes.TainanCity.geometry}
          material={materials.black}
          position={[-0.223662, -0.554262, 0]}
        />
        <mesh
          name="HsinchuCity"
          geometry={nodes.HsinchuCity.geometry}
          material={materials.black}
          position={[0.190276, 0.636097, 0]}
        />
        <mesh
          name="HsinchuCountry"
          geometry={nodes.HsinchuCountry.geometry}
          material={materials.black}
          position={[0.32923, 0.566177, 0]}
        />
        <mesh
          name="YilanCountry"
          geometry={nodes.YilanCountry.geometry}
          material={materials.black}
          position={[0.646409, 0.485567, 0]}
        />
        <mesh
          name="KeelungCity"
          geometry={nodes.KeelungCity.geometry}
          material={materials.black}
          position={[0.694483, 0.879278, 0]}
        />
        <mesh
          name="MiaoliCountry"
          geometry={nodes.MiaoliCountry.geometry}
          material={materials.black}
          position={[0.166294, 0.420212, 0]}
        />
        <mesh
          name="TaipeiCity"
          geometry={nodes.TaipeiCity.geometry}
          material={materials.black}
          position={[0.595474, 0.856797, 0]}
        />
        <mesh
          name="NewTaipeiCity"
          geometry={nodes.NewTaipeiCity.geometry}
          material={materials.black}
          position={[0.615812, 0.786084, 0]}
        />
        <mesh
          name="TaoyuanCountry"
          geometry={nodes.TaoyuanCountry.geometry}
          material={materials.black}
          position={[0.397512, 0.721097, 0]}
        />
        <mesh
          name="ChanghuaCountry"
          geometry={nodes.ChanghuaCountry.geometry}
          material={materials.black}
          position={[-0.12405, 0.03245, 0]}
        />
        <mesh
          name="ChiayiCountry"
          geometry={nodes.ChiayiCountry.geometry}
          material={materials.black}
          position={[-0.099615, -0.336385, 0]}
        />
        <mesh
          name="ChiayiCity"
          geometry={nodes.ChiayiCity.geometry}
          material={materials.black}
          position={[-0.15079, -0.315262, 0]}
        />
        <mesh
          name="HualienCountry"
          geometry={nodes.HualienCountry.geometry}
          material={materials.black}
          position={[0.473711, -0.116171, 0]}
        />
        <mesh
          name="NantouCountry"
          geometry={nodes.NantouCountry.geometry}
          material={materials.black}
          position={[0.212877, -0.048316, 0]}
        />
        <mesh
          name="TaichungCity"
          geometry={nodes.TaichungCity.geometry}
          material={materials.black}
          position={[0.150413, 0.241351, 0]}
        />
        <mesh
          name="YunlinCountry"
          geometry={nodes.YunlinCountry.geometry}
          material={materials.black}
          position={[-0.186642, -0.165699, 0]}
        />
        <mesh
          name="TaitungCountry"
          geometry={nodes.TaitungCountry.geometry}
          material={materials.black}
          position={[0.248513, -0.762825, 0]}
        />
        <mesh
          name="PenghuCountry"
          geometry={nodes.PenghuCountry.geometry}
          material={materials.black}
          position={[-0.764586, -0.519908, 0]}
        />
        <mesh
          name="KinmenCountry"
          geometry={nodes.KinmenCountry.geometry}
          material={materials.black}
          position={[-0.68671, 0.190579, 0]}
        />
        <mesh
          name="LienchiangCountry"
          geometry={nodes.LienchiangCountry.geometry}
          material={materials.black}
          position={[-0.428144, 0.965172, 0]}
        />
      </group>
    </>
  );
}

useGLTF.preload('/tw3d.glb');
